# Sort

## 选择排序

> 选择排序（Selection sort）是一种简单直观的[排序算法](https://baike.baidu.com/item/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/5399605)。它的工作原理是：第一次从待排序的[数据元素](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0/715313)中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。<font color="red">选择排序是不稳定的排序方法</font>。

**代码:**

```js
// 选择排序
const selectSort = (arr) => {
  const len = arr.length;
  for(let i = 0;i < len;i++){
    for(let j = i+1;j < len;j++){
      if(arr[i] > arr[j]){
        [arr[i],arr[j]] = [arr[j],arr[i]]; // 进行数值交换
      }
    }
  }
  console.log(arr);
}
```

## 冒泡排序

> 冒泡排序（Bubble Sort），是一种[计算机科学](https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/9132)领域的较简单的[排序算法](https://baike.baidu.com/item/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/5399605)。
> 
> 它重复地走访过要排序的元素列，依次比较两个相邻的[元素](https://baike.baidu.com/item/%E5%85%83%E7%B4%A0/9563223)，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。
> 
> 这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中[二氧化碳](https://baike.baidu.com/item/%E4%BA%8C%E6%B0%A7%E5%8C%96%E7%A2%B3/349143)的气泡最终会上浮到顶端一样，故名“冒泡排序”。

冒泡排序算法的原理如下：

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。

2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 

3. 针对所有的元素重复以上的步骤，除了最后一个。

4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

$$
时间复杂度:O(n^2)
$$

**代码:**

```js
// 冒泡排序
const bubbleSort = (arr) => {
  const len = arr.length;
  for(let i = 0;i < len;i++){
    for(let j = 1;j < len;j++){
      if(arr[j-1] > arr[j]){
        [arr[j-1],arr[j]] = [arr[j],arr[j-1]];
      }
    }
  }
  console.log(arr);
}
```

## 插入排序

> 插入排序，一般也被称为直接插入排序。对于少量元素的排序，它是一个有效的算法 。插入排序是一种最简单的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动 。

对于一个长度为n的数组,先将0~1进行排序,然后0~2进行排序,……,0~n进行排序

**代码:**

```js
// 插入排序
const insertSort = (arr) => {
    for(let i = 1; i < arr.length; i++){
        // 当j <= 0 或者arr[j]不大于arr[j+1]时,就需要循环了
        // 前面都是有序的
        for(let j = i-1;j >= 0 && arr[j] > arr[j+1];j--){
            [arr[j],arr[j+1]] = [arr[j+1],arr[j]];
        }
    }
    console.log(arr);
}og(arr);
}
```

$$
最差时的时间复杂度: O(n^2)
$$

# 
